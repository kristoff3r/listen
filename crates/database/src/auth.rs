use diesel::{
    delete, insert_into, prelude::*, update, upsert::excluded, QueryDsl, Selectable,
    SelectableHelper,
};
use diesel_async::{AsyncPgConnection, RunQueryDsl};
use openidconnect::{CsrfToken, Nonce, PkceCodeVerifier};
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;

use typed_uuid::Uuid;

pub type UserId = Uuid<User>;
pub type UserSessionId = Uuid<UserSession>;

#[derive(Queryable, Selectable, Identifiable)]
#[diesel(primary_key(user_id))]
#[diesel(table_name = crate::schema::users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    pub user_id: UserId,
    pub created_at: OffsetDateTime,
    pub updated_at: OffsetDateTime,
    pub email: String,
    pub handle: String,
    pub oidc_issuer_url: String,
    pub profile_picture_url: String,
    pub is_approved: bool,
    pub is_admin: bool,
}

#[derive(Insertable)]
#[diesel(table_name = crate::schema::users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NewUser<'a> {
    pub email: &'a str,
    pub handle: &'a str,
    pub oidc_issuer_url: &'a str,
    pub profile_picture_url: &'a str,
    pub is_approved: bool,
    pub is_admin: bool,
}

#[derive(Queryable, Selectable, Identifiable)]
#[diesel(primary_key(user_session_id))]
#[diesel(table_name = crate::schema::user_sessions)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserSession {
    pub user_session_id: UserSessionId,
    pub created_at: OffsetDateTime,
    pub updated_at: OffsetDateTime,
    // This info is generated by the oidc client and is needed
    // to validate that the user has successfully logged in.
    // Delete after logging in
    pub oidc_issuer_url: Option<String>,
    pub csrf_token: Option<String>,
    pub nonce: Option<String>,
    pub pkce_code_verifier: Option<String>,
    //
    // // Only set after logged in
    pub user_id: Option<UserId>,
}

#[derive(Insertable)]
#[diesel(table_name = crate::schema::user_sessions)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NewUserSession<'a> {
    pub oidc_issuer_url: &'a str,
    pub csrf_token: &'a str,
    pub nonce: &'a str,
    pub pkce_code_verifier: &'a str,
}

pub async fn create_or_update(
    conn: &mut AsyncPgConnection,
    email: &str,
    oidc_issuer_url: &str,
    profile_picture_url: &str,
) -> anyhow::Result<User> {
    use crate::schema::users::dsl as u;

    let handle = format!("Anonymous{}", rand::random::<u32>());

    let user = insert_into(u::users)
        .values(NewUser {
            email,
            handle: &handle,
            oidc_issuer_url,
            profile_picture_url,
            is_approved: false,
            is_admin: false,
        })
        .on_conflict((u::email, u::oidc_issuer_url))
        .do_update()
        .set(u::profile_picture_url.eq(excluded(u::profile_picture_url)))
        .returning(User::as_select())
        .get_result(conn)
        .await?;

    Ok(user)
}

pub async fn list_users(conn: &mut AsyncPgConnection) -> anyhow::Result<Vec<User>> {
    use crate::schema::users::dsl as u;
    let users = u::users.get_results(conn).await?;
    Ok(users)
}

pub async fn query_user_by_id(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
) -> anyhow::Result<User> {
    use crate::schema::users::dsl as u;
    let user = u::users.find(user_id).first(conn).await?;
    Ok(user)
}

pub async fn query_user_by_email_and_oidc_issuer_url(
    conn: &mut AsyncPgConnection,
    email: &str,
    oidc_issuer_url: &str,
) -> anyhow::Result<User> {
    use crate::schema::users::dsl as u;
    let user = u::users
        .filter(u::email.eq(email))
        .filter(u::oidc_issuer_url.eq(oidc_issuer_url))
        .select(User::as_select())
        .first(conn)
        .await?;
    Ok(user)
}

pub async fn update_handle(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
    handle: String,
) -> anyhow::Result<()> {
    use crate::schema::users::dsl as u;
    update(u::users)
        .filter(u::user_id.eq(user_id))
        .set(u::handle.eq(handle))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn set_approved(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
    is_approved: bool,
) -> anyhow::Result<()> {
    use crate::schema::users::dsl as u;
    update(u::users)
        .filter(u::user_id.eq(user_id))
        .set(u::is_approved.eq(is_approved))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn set_admin(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
    is_admin: bool,
) -> anyhow::Result<()> {
    use crate::schema::users::dsl as u;
    update(u::users)
        .filter(u::user_id.eq(user_id))
        .set(u::is_admin.eq(is_admin))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn new_session(
    conn: &mut AsyncPgConnection,
    oidc_issuer_url: &str,
    csrf_token: CsrfToken,
    nonce: Nonce,
    pkce_code_verifier: PkceCodeVerifier,
) -> anyhow::Result<UserSessionId> {
    use crate::schema::user_sessions::dsl as s;

    let session_id = insert_into(s::user_sessions)
        .values(NewUserSession {
            oidc_issuer_url,
            csrf_token: csrf_token.secret(),
            nonce: nonce.secret(),
            pkce_code_verifier: pkce_code_verifier.secret(),
        })
        .returning(s::user_session_id)
        .get_result(conn)
        .await?;
    Ok(session_id)
}

pub async fn delete_session(
    conn: &mut AsyncPgConnection,
    user_session_id: UserSessionId,
) -> anyhow::Result<()> {
    use crate::schema::user_sessions::dsl as s;

    delete(s::user_sessions)
        .filter(s::user_session_id.eq(user_session_id))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn log_session_in(
    conn: &mut AsyncPgConnection,
    user_session_id: UserSessionId,
    user_id: UserId,
) -> anyhow::Result<()> {
    use crate::schema::user_sessions::dsl as s;

    update(s::user_sessions)
        .filter(s::user_session_id.eq(user_session_id))
        .set((
            s::user_id.eq(user_id),
            s::oidc_issuer_url.eq(None::<String>),
            s::csrf_token.eq(None::<String>),
            s::nonce.eq(None::<String>),
            s::pkce_code_verifier.eq(None::<String>),
        ))
        .execute(conn)
        .await?;
    Ok(())
}
