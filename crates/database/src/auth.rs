use std::marker::PhantomData;

use diesel::{
    delete, insert_into, prelude::*, update, upsert::excluded, QueryDsl, Selectable,
    SelectableHelper,
};
use diesel_async::{AsyncPgConnection, RunQueryDsl};
use openidconnect::{CsrfToken, Nonce, PkceCodeVerifier};
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;

struct Uuid<T> {
    uuid: uuid::Uuid,
    marker: PhantomData<T>,
}

impl<T> std::fmt::Debug for Uuid<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.uuid.fmt(f)
    }
}

impl<T> std::hash::Hash for Uuid<T> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.uuid.hash(state);
    }
}

impl<T> std::cmp::Eq for Uuid<T> {}
impl<T> std::cmp::PartialEq for Uuid<T> {
    fn eq(&self, other: &Self) -> bool {
        self.uuid == other.uuid
    }
}
impl<T> Clone for Uuid<T> {
    fn clone(&self) -> Self {
        Self {
            uuid: self.uuid.clone(),
            marker: PhantomData,
        }
    }
}

impl<T> serde::Serialize for Uuid<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.uuid.serialize(serializer)
    }
}

impl<'de, T> serde::Deserialize<'de> for Uuid<T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Ok(Self {
            uuid: uuid::Uuid::deserialize(deserializer)?,
            marker: PhantomData,
        })
    }
}

impl<T> std::ops::Deref for Uuid<T> {
    type Target = uuid::Uuid;

    fn deref(&self) -> &Self::Target {
        &self.uuid
    }
}

// pub type UserId = Uuid<User>;

pub type UserId = uuid::Uuid;
pub type UserSessionId = uuid::Uuid;

#[derive(Queryable, Selectable, Identifiable)]
#[diesel(primary_key(user_id))]
#[diesel(table_name = crate::schema::users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    pub user_id: UserId,
    pub created_at: OffsetDateTime,
    pub updated_at: OffsetDateTime,
    pub email: String,
    pub handle: String,
    pub oidc_issuer_url: String,
    pub profile_picture_url: String,
    pub is_approved: bool,
    pub is_admin: bool,
}

#[derive(Insertable)]
#[diesel(table_name = crate::schema::users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NewUser<'a> {
    pub email: &'a str,
    pub handle: &'a str,
    pub oidc_issuer_url: &'a str,
    pub profile_picture_url: &'a str,
    pub is_approved: bool,
    pub is_admin: bool,
}

#[derive(Queryable, Selectable, Identifiable)]
#[diesel(primary_key(user_session_id))]
#[diesel(table_name = crate::schema::user_sessions)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserSession {
    pub user_session_id: UserSessionId,
    pub created_at: OffsetDateTime,
    pub updated_at: OffsetDateTime,
    // This info is generated by the oidc client and is needed
    // to validate that the user has successfully logged in.
    // Delete after logging in
    pub oidc_issuer_url: Option<String>,
    pub csrf_token: Option<String>,
    pub nonce: Option<String>,
    pub pkce_code_verifier: Option<String>,
    //
    // // Only set after logged in
    pub user_id: Option<UserId>,
}

#[derive(Insertable)]
#[diesel(table_name = crate::schema::user_sessions)]
#[diesel(check_for_backend(diesel::pg::Pg))]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NewUserSession<'a> {
    pub oidc_issuer_url: &'a str,
    pub csrf_token: &'a str,
    pub nonce: &'a str,
    pub pkce_code_verifier: &'a str,
}

pub async fn create_or_update(
    conn: &mut AsyncPgConnection,
    email: &str,
    oidc_issuer_url: &str,
    profile_picture_url: &str,
) -> anyhow::Result<User> {
    use crate::schema::users::dsl as u;

    let handle = format!("Anonymous{}", rand::random::<u32>());

    let user = insert_into(u::users)
        .values(NewUser {
            email,
            handle: &handle,
            oidc_issuer_url,
            profile_picture_url,
            is_approved: false,
            is_admin: false,
        })
        .on_conflict((u::email, u::oidc_issuer_url))
        .do_update()
        .set(u::profile_picture_url.eq(excluded(u::profile_picture_url)))
        .returning(User::as_select())
        .get_result(conn)
        .await?;

    Ok(user)
}

pub async fn list_users(conn: &mut AsyncPgConnection) -> anyhow::Result<Vec<User>> {
    use crate::schema::users::dsl as u;
    let users = u::users.get_results(conn).await?;
    Ok(users)
}

pub async fn query_user_by_id(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
) -> anyhow::Result<User> {
    use crate::schema::users::dsl as u;
    let user = u::users.find(user_id).first(conn).await?;
    Ok(user)
}

pub async fn query_user_by_email_and_oidc_issuer_url(
    conn: &mut AsyncPgConnection,
    email: &str,
    oidc_issuer_url: &str,
) -> anyhow::Result<User> {
    use crate::schema::users::dsl as u;
    let user = u::users
        .filter(u::email.eq(email))
        .filter(u::oidc_issuer_url.eq(oidc_issuer_url))
        .select(User::as_select())
        .first(conn)
        .await?;
    Ok(user)
}

pub async fn update_handle(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
    handle: String,
) -> anyhow::Result<()> {
    use crate::schema::users::dsl as u;
    update(u::users)
        .filter(u::user_id.eq(user_id))
        .set(u::handle.eq(handle))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn set_approved(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
    is_approved: bool,
) -> anyhow::Result<()> {
    use crate::schema::users::dsl as u;
    update(u::users)
        .filter(u::user_id.eq(user_id))
        .set(u::is_approved.eq(is_approved))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn set_admin(
    conn: &mut AsyncPgConnection,
    user_id: UserId,
    is_admin: bool,
) -> anyhow::Result<()> {
    use crate::schema::users::dsl as u;
    update(u::users)
        .filter(u::user_id.eq(user_id))
        .set(u::is_admin.eq(is_admin))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn new_session(
    conn: &mut AsyncPgConnection,
    oidc_issuer_url: &str,
    csrf_token: CsrfToken,
    nonce: Nonce,
    pkce_code_verifier: PkceCodeVerifier,
) -> anyhow::Result<UserSessionId> {
    use crate::schema::user_sessions::dsl as s;

    let session_id = insert_into(s::user_sessions)
        .values(NewUserSession {
            oidc_issuer_url,
            csrf_token: csrf_token.secret(),
            nonce: nonce.secret(),
            pkce_code_verifier: pkce_code_verifier.secret(),
        })
        .returning(s::user_session_id)
        .get_result(conn)
        .await?;
    Ok(session_id)
}

pub async fn delete_session(
    conn: &mut AsyncPgConnection,
    user_session_id: UserSessionId,
) -> anyhow::Result<()> {
    use crate::schema::user_sessions::dsl as s;

    delete(s::user_sessions)
        .filter(s::user_session_id.eq(user_session_id))
        .execute(conn)
        .await?;
    Ok(())
}

pub async fn log_session_in(
    conn: &mut AsyncPgConnection,
    user_session_id: UserSessionId,
    user_id: UserId,
) -> anyhow::Result<()> {
    use crate::schema::user_sessions::dsl as s;

    update(s::user_sessions)
        .filter(s::user_session_id.eq(user_session_id))
        .set((
            s::user_id.eq(user_id),
            s::oidc_issuer_url.eq(None::<String>),
            s::csrf_token.eq(None::<String>),
            s::nonce.eq(None::<String>),
            s::pkce_code_verifier.eq(None::<String>),
        ))
        .execute(conn)
        .await?;
    Ok(())
}
